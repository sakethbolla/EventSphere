name: Deploy to Production (EKS)

# Production deployment workflow
# - Runs automatically on main branch after staging deployment succeeds
# - Can also be triggered manually for other environments

on:
  workflow_run:
    workflows: ["Deploy to Staging (kind)"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - prod
          - staging
          - dev
      image_tag:
        description: 'Image tag to deploy (default: latest)'
        required: false
        default: 'latest'
      skip_templates:
        description: 'Skip template processing'
        required: false
        type: boolean
        default: false

env:
  AWS_REGION: us-east-1
  CLUSTER_NAME: eventsphere-cluster

jobs:
  deploy:
    name: Deploy to EKS (Production)
    runs-on: ubuntu-latest
    # Only run if staging succeeded (on main) or manual dispatch
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'main') ||
      github.event_name == 'workflow_dispatch'
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.ref }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Configure kubeconfig
        run: |
          aws eks update-kubeconfig --name ${{ env.CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

      - name: Set deployment environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          else
            # Auto-deploy to prod on main branch
            echo "environment=prod" >> $GITHUB_OUTPUT
          fi

      - name: Set image tag
        id: set-tag
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          else
            # Use commit SHA for deployments (matches build workflow)
            echo "tag=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
          fi

      - name: Get AWS Account ID
        id: get-account-id
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
          echo "AWS Account ID: $ACCOUNT_ID"

      - name: Process Kubernetes templates
        if: github.event.inputs.skip_templates != 'true'
        run: |
          # Install gettext for envsubst
          sudo apt-get update && sudo apt-get install -y gettext-base
          
          # Set environment variables
          export AWS_ACCOUNT_ID="${{ steps.get-account-id.outputs.account_id }}"
          export AWS_REGION="${{ env.AWS_REGION }}"
          export ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          export CLUSTER_NAME="${{ env.CLUSTER_NAME }}"
          export ACM_CERTIFICATE_ARN="${{ secrets.ACM_CERTIFICATE_ARN }}"
          export FLUENT_BIT_ROLE_ARN="arn:aws:iam::${AWS_ACCOUNT_ID}:role/fluent-bit-role"
          export EXTERNAL_SECRETS_ROLE_ARN="arn:aws:iam::${AWS_ACCOUNT_ID}:role/external-secrets-role"
          
          # Create output directory
          mkdir -p k8s/generated/base
          mkdir -p k8s/generated/ingress
          mkdir -p k8s/generated/overlays/${{ steps.set-env.outputs.environment }}
          
          # Process template files
          find k8s -name "*.template" -type f | while read template; do
            output_file=$(echo "$template" | sed 's/\.template$//' | sed 's|k8s/|k8s/generated/|')
            output_dir=$(dirname "$output_file")
            mkdir -p "$output_dir"
            envsubst < "$template" > "$output_file"
            echo "Processed: $template -> $output_file"
          done
          
          # Copy non-template files
          cp -r k8s/base/*.yaml k8s/generated/base/ 2>/dev/null || true
          cp -r k8s/ingress/*.yaml k8s/generated/ingress/ 2>/dev/null || true
          cp -r k8s/overlays/${{ steps.set-env.outputs.environment }}/*.yaml k8s/generated/overlays/${{ steps.set-env.outputs.environment }}/ 2>/dev/null || true

      - name: Set lowercase image prefix
        id: image-prefix
        run: |
          echo "prefix=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Update image tags in deployments
        run: |
          # Default to GHCR (matches build workflow), but allow ECR override
          if [ -n "${{ secrets.USE_ECR }}" ] && [ "${{ secrets.USE_ECR }}" == "true" ]; then
            IMAGE_REGISTRY="${{ steps.get-account-id.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
            echo "Using ECR registry: ${IMAGE_REGISTRY}"
          else
            IMAGE_REGISTRY="ghcr.io/${{ steps.image-prefix.outputs.prefix }}"
            echo "Using GHCR registry: ${IMAGE_REGISTRY}"
          fi
          IMAGE_TAG="${{ steps.set-tag.outputs.tag }}"
          
          # Update image tags in deployment files
          find k8s/generated -name "*deployment.yaml" -type f | while read file; do
            sed -i "s|image:.*auth-service.*|image: ${IMAGE_REGISTRY}/auth-service:${IMAGE_TAG}|g" "$file"
            sed -i "s|image:.*event-service.*|image: ${IMAGE_REGISTRY}/event-service:${IMAGE_TAG}|g" "$file"
            sed -i "s|image:.*booking-service.*|image: ${IMAGE_REGISTRY}/booking-service:${IMAGE_TAG}|g" "$file"
            sed -i "s|image:.*frontend.*|image: ${IMAGE_REGISTRY}/frontend:${IMAGE_TAG}|g" "$file"
          done
          
          echo "Updated image tags to: ${IMAGE_REGISTRY}/*:${IMAGE_TAG}"

      - name: Apply ConfigMaps
        run: |
          kubectl apply -f k8s/generated/base/configmaps.yaml -n ${{ steps.set-env.outputs.environment }} || true

      - name: Apply RBAC
        run: |
          kubectl apply -f k8s/generated/base/rbac.yaml

      - name: Apply Deployments and Services
        run: |
          kubectl apply -f k8s/generated/base/ -n ${{ steps.set-env.outputs.environment }}

      - name: Apply HPA configurations
        run: |
          kubectl apply -f k8s/hpa/ -n ${{ steps.set-env.outputs.environment }} || true

      - name: Wait for deployments to be ready
        run: |
          echo "Waiting for deployments to be ready..."
          for deployment in auth-service event-service booking-service frontend; do
            if kubectl get deployment "$deployment" -n ${{ steps.set-env.outputs.environment }} &> /dev/null; then
              echo "Waiting for $deployment..."
              kubectl wait --for=condition=available --timeout=300s \
                deployment/"$deployment" -n ${{ steps.set-env.outputs.environment }} || {
                echo "Deployment $deployment not ready within timeout"
                kubectl describe deployment "$deployment" -n ${{ steps.set-env.outputs.environment }}
                kubectl logs -n ${{ steps.set-env.outputs.environment }} -l app="$deployment" --tail=50
                exit 1
              }
              echo "$deployment is ready"
            fi
          done

      - name: Apply Ingress
        run: |
          kubectl apply -f k8s/generated/ingress/ -n ${{ steps.set-env.outputs.environment }} || true

      - name: Verify deployment
        run: |
          echo "=== Deployment Status ==="
          kubectl get deployments -n ${{ steps.set-env.outputs.environment }}
          echo ""
          echo "=== Pod Status ==="
          kubectl get pods -n ${{ steps.set-env.outputs.environment }}
          echo ""
          echo "=== Service Status ==="
          kubectl get services -n ${{ steps.set-env.outputs.environment }}
          echo ""
          echo "=== Ingress Status ==="
          kubectl get ingress -n ${{ steps.set-env.outputs.environment }} || echo "No ingress found"

      - name: Rollback on failure
        if: failure()
        run: |
          echo "Deployment failed, attempting rollback..."
          for deployment in auth-service event-service booking-service frontend; do
            if kubectl get deployment "$deployment" -n ${{ steps.set-env.outputs.environment }} &> /dev/null; then
              kubectl rollout undo deployment/"$deployment" -n ${{ steps.set-env.outputs.environment }} || true
            fi
          done
          exit 1

